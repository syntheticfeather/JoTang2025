# 单调栈

> 不能称为一种数据结构，只是一种解决问题的算法技巧
> 通过特定的入栈，出站条件，让栈中元素呈现了一种递增或递减的规律。

## 思想

1. 缓存未处理的问题，在后续一起解决
2. 缓存可能的解，在后续解决问题时使用

## 应用

两种思想其实一道题倒序和正序的不同。

解决了**右侧/左侧**的**第一个更小/更大**的元素问题，NGE（Next Greater Element）

* 右侧的第一个更大的
* 右侧的第一个更小的
* 左侧的第一个更小的
* 左侧的第一个更大的

### 例1

>给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。

>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。

>请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。

---

其实就是找右侧第一个更小或者相等的元素。

#### 解法

1. $O(n^2)$的**暴力求解**

2. $O(n)$的**单调栈**解法

    * **从左往右遍历**

        栈中存储**需要找到折扣的元素**

        每遇到一个**元素A**，则与**栈顶元素B**对比

        * 如果**当前元素A**更小，则可作为**栈顶元素B**的折扣。
        
            记录B位置的答案。B出栈，重复比较**下一个栈顶元素B**

        * 如果**当前元素A**大于等于**栈顶元素B**，则不能作为**栈顶元素B**的折扣。
    
            所以A入栈，继续等待

        可以看出，能入栈，那入栈元素必然比栈顶元素大。

        所以栈呈现出了单调的形式。

        ```java
            public int[] finalPrices(int[] prices) {
            int n = prices.length;
            int[] ans = prices.clone();
            Stack<Integer> stack = new Stack<>();
            for (int i = 0; i < n; i++) {
                while (!stack.empty() && prices[stack.peek()] >= prices[i]) {
                    int idx = stack.pop();
                    ans[idx] = prices[idx] - prices[i];
                }
                stack.push(i);
            }
            return ans;
        }
        ```

    * **从右往左遍历**
    
        栈中存储可能作为折扣的元素。

        每遇到一个**元素A**，则与**栈顶元素B**对比

        * 如果**当前元素A**更大，则**栈顶元素B**可以作为**元素A**的折扣
        
            记录**元素A**位置的答案。并且**元素A**入栈

        * 如果**当前元素A**小于**栈顶元素B**，则**元素B**不能作为**元素A**的折扣。
  
            那么弹出**元素B**，比较下一个**栈顶元素B**

        可以看出元素A只有在比栈顶元素大的时候才会入栈。

        因此栈呈现出了从底到顶递增的形式。

        ```java
            public int[] finalPrices(int[] prices) {
                int n = prices.length;
                int[] ans = new int[n];
                Deque<Integer> stack = new ArrayDeque<Integer>();
                for (int i = n - 1; i >= 0; i--) {
                    while (!stack.isEmpty() && stack.peek() > prices[i]) {
                        stack.pop();
                    }
                    ans[i] = stack.isEmpty() ? prices[i] : prices[i] - stack.peek();
                    stack.push(prices[i]);
                }
                return ans;
            }
        ```

### 例2

> 给定一个整数数组 temperatures ，表示每天的温度，

> 返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。

> 如果气温在这之后都不会升高，请在该位置用 0 来代替。

---

就是找右侧第一个更大的值

#### 解法

* 暴力解法

* 单调栈

```java
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        Deque<Integer> stack = new ArrayDeque<>();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int j = stack.pop();
                ans[j] = i - j;
            }
            stack.push(i);
        }
        return ans;
    }
```


## 变种

无非就是**存储的信息变化**，**记录的答案的变化**，**或者是双单调栈存储多个信息**。


4 3 2 1 0
x z y t a

x z . . > x y t a

则 z > y

所以 当下位更小，移除上位

找右侧第一个更小的，

z == y ？

x z z z t a

x z z t a

x z z t a

1 1 1 9 8 8 8       3

1 1 1 8 8 8         2

1 8 8 8 
1 1 8 8
1 1 1 8